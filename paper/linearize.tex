%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iftechreport{
\begin{figure}[t]
  \centering
  \begin{minipage}{0.4\linewidth}
  \begin{gather*}
    \label{eq:1}
    %%%%%%%%%%%%%%%%%%%%%
    % v1 < v2
    \frac{\expr \defas \expr_1 < \expr_2}{
      \begin{aligned}
        \var_1 - \var_2 + \bvar \times \upBound &\geq 0\\
        \var_2 - \var_1 + (1- \bvar) \times \upBound &> 0
      \end{aligned}
% \splitfrac{\var_1 - \var_2 + \var \times \upBound \geq 0}
% {\var_2 - \var_1 + (1- \var) \times \upBound > 0}
    }\\
    %%%%%%%%%%%%%%%%%%%%
    % v1 = v2
%     &\frac{\expr := \expr_1 = \expr_2}{
%       \begin{aligned}
% \var_1 - \var_2 + \bvar \times \upBound &> 0\\
% \var_2 -\var_1 + (1- \bvar) \times \upBound &\geq 0\\
% \var_2 - \var_1 + \bvar \times \upBound &> 0\\
% \var_1 -\var_2 + (1- \bvar) \times \upBound &\geq 0
%       \end{aligned}
%     }\\
    %%%%%%%%%%%%%%%%%%%%
    % v1 <= v2
    \frac{ \expr \defas \expr_1 \leq \expr_2}{
      \begin{aligned}
        \var_1 - \var_2 + \bvar \times \upBound &> 0\\
        \var_2 - \var_1 + (1- \bvar) \times \upBound &\geq 0
      \end{aligned}
    }\\
    %%%%%%%%%%%%%%%%%%%%
    % v1 AND v2
    \frac{\expr := \expr_1 \wedge \expr_2}{
      \begin{aligned}
        \bvar_1 +\bvar_2 -2\bvar -1 &\leq 0 \\
        \bvar_1 +\bvar_2 -2\bvar &\geq 0
      \end{aligned}
    }\\
    %%%%%%%%%%%%%%%%%%%%
    % v1 OR v2
    \frac{\expr := \expr_1 \vee \expr_2}{
      \begin{aligned}
        \bvar_1 +\bvar_2 -2\bvar &\leq 0 \\
        \bvar_1 +\bvar_2 -\bvar &\geq 0
      \end{aligned}
    }\\
    %%%%%%%%%%%%%%%%%%%%
    % v1 + v2
     \frac{\expr \defas \expr_1 + \expr_2}{\var_1 + \var_2 - \var = 0}
    %%%%%%%%%%%%%%%%%%%%
    % if v1 then v2 else v3
    %                                                              &  & \frac{\expr \defas \sqlCase{\expr_c}{\expr_1}{\expr_2}}{
    %   \begin{aligned}
    %     \var_{if} + \var_{else} - \var                           & = 0\\
    %     %%%%%%%%%%%%%%%%%%%%
    %     \var_{if} - \var_1                                       & \leq 0  \\
    %     \var_{if} - \var_1 + \upBound - \upBound \cdot \bvar_{c} & \geq 0\\
    %     \var_{if} - \upBound  \cdot \bvar_{c}                    & \leq 0 \\
    %     \var_{if} + \bvar_{c}  \cdot \upBound                    & \geq 0\\
    %     %%%%%%%%%%%%%%%%%%%%
    %     \var_{else} - \var_2                                     & \leq 0 \\
    %     \var_{else} - \upBound + \upBound \cdot \bvar_{c}        & \leq 0\\
    %     \var_{else} - \var_2 + \upBound \cdot \bvar_{c}          & \geq 0\\
    %     \var_{else} + \upBound - \upBound \cdot \bvar_{c}        & \geq 0
    %   \end{aligned}
    %   }
    %%%%%%%%%%%%%%%%%%%%
    % can't do multiplication and division except for by constant or with a very limited domain
  \end{gather*}
  \end{minipage}
  \begin{minipage}{0.49\linewidth}
    \[
      \frac{\expr \defas \sqlCase{\expr_c}{\expr_1}{\expr_2}}{
      \begin{aligned}
        \var_{if} + \var_{else} - \var                             & = 0    \\
        %%%%%%%%%%%%%%%%%%%%
        \var_{if} - \var_1                                         & \leq 0 \\
        \var_{if} - \var_1 + \upBound - \upBound \cdot \bvar_{c}   & \geq 0 \\
        \var_{if} - \upBound  \cdot \bvar_{c}                      & \leq 0 \\
        \var_{if} + \bvar_{c}  \cdot \upBound                      & \geq 0 \\
        %%%%%%%%%%%%%%%%%%%%
        \var_{else} - \var_2                                       & \leq 0 \\
        \var_{else} - \upBound + \upBound \cdot \bvar_{c}          & \leq 0 \\
        \var_{else} - \var_2 + \upBound \cdot \bvar_{c}            & \geq 0 \\
        \var_{else} + \upBound - \upBound \cdot \bvar_{c}          & \geq 0
      \end{aligned}
    }
  \]
  %
  \begin{gather*}
    %%%%%%%%%%%%%%%%%%%%
    % x
    \frac{\expr \defas x}{\var_{x}}
    %%%%%%%%%%%%%%%%%%%%
    % not v1
     \frac{\expr \defas \neg \expr_1 }{
      \bvar + \bvar_1 =1
    }
  \end{gather*}
  %%%%%%%%%%%%%%%%%%%%
  \end{minipage}

  \caption{Compilation rules for translating constraints into an MILP (the remaining comparison operators are omitted since they can be expressed using boolean operations).}
  \label{fig:milp-compilation}
\end{figure}

In these rules we use $\var$, $var_1$, \ldots to denote integer variables and $\bvar$, $\bvar_1$, \ldots to denote boolean variables. Furthermore, $\upBound$ denotes an integer constant that is larger than all integer values used as attribute values.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iftechreport{
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MILP Compilation}
\label{sec:sym-lin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To evaluate the conditions $\aslicetest$ for program slicing, we first translate these conditions into existential form and then translate them into a MILP (mixed integer linear programming) program~\cite{schrijver1998theory}. The resulting program can then be solved using a standard MILP solver, e.g., we use CPLEX~\cite{cplex2009v12} to test the satisfiability of these conditions. % generated by our dependency checking solution presented in the previous section.
% However, these conditions are typically not linear.
We now introduce a compilation scheme that translates such logical expressions into linear constraints. This compilation scheme consists of a set of rules that are shown in \cite{techreport}.  These rules are applied recursively to a constraint. Each rule generates a set of linear constraints. The MILP generated by these rules for a boolean expression $\expr$ consists of the union of all linear constraints produced by the rules for the subexpressions of $e$. For each subexpression $\expr'$ of $\expr$, the compilation produces a variable $\var'$ ($\bvar'$ if $\expr'$ is boolean) for which any solution to the MILP sets $\var'$ ($\bvar'$) to the value that $\expr'$ evaluates to. An additional constraint $\bvar = 1$ is added to ensure that only solutions that satisfy $\expr$ are produced. %Note that we only use the MILP solver for satisfiable testing (cplex has an option for that).
% Thus, for any solution to the MILP we have that $\var$ stores the value of expression $\expr$ for the values chosen for variables in the expression.
% The objective function is set to $sum(v)$ such that the constraint solver to return a solution which satisfies the condition $\expr$ if such a solution exists.
The translation rules applied here are mostly well-known rules applied in linear programming and many have been used in related work (e.g.,~\cite{MeliouS12}).
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "historical_whatif"
%%% End:
