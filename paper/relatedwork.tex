\section{Related Work}
\label{sec:related-work}

%

% 
%%%%%%%%%%%%%%%%%%%%%%%%
What-if queries determine the effect of a hypothetical change to an input database on the results of a query.
To avoid having to reevaluate the query over the full input including the hypothetical changes, incremental view maintenance is often applied to answer what-if queries~\cite{hung17,deutch13,ZG95,bourhis16}. % to the data to evaluate the effect of the change on the query's output.
The how-to queries of Tiresias~\cite{MeliouS12}  determine how to translate a  change
to a query result into modifications of the input data. Similar to their approach, our system utilizes
%
Mixed Integer Programming to express a set of possible worlds. % on top of a relational database system.
The QFix system~\cite{wang16} is essentially a variation on this where the change to the output has to be achieved by a change to a query (update) workload.
The query slicing technique of QFix is similar to our program slicing optimization. The main difference is that
we apply symbolic execution to a single tuple instance, i.e.,
the number of constraints we produce is independent of the database size.
% 
 % 
%
%

% 
% 
Several provenance models for relational queries have been studied such as Why-provenance, minimal Why-provenance~\cite{BK01}, and Lineage~\cite{CW00b}. The K-relations introduced by Green et al.~\cite{GK07} generalize these models for positive relational algebra.
%
%
%
%
%
In~\cite{AG14,AG17,AG18} we have introduced  MV-semirings~\cite{AG14,AG17,AG18} as an extension of K-relations that supports transactional updates. Furthermore, we did introduce reenactment as a technique for replaying histories using queries. The reenactment query for a history is equivalent to the  history under MV-semiring semantics~\cite{AG14,AG17,AG18}, i.e., it returns the same database state and provenance. \cite{bourhis-20-eqinalphupq} did study extensions of semiring-annotated relations for updates that allow updates to be deleted from a history. However, this approach only supports a limited class of updates.
%

The connection of provenance and program slicing was % to the best of our knowledge
first observed in~\cite{cheney07}.
%
%
%
We present a method that statically analyzes potential provenance dependencies among statements in the history using a method which borrows ideas from symbolic execution~\cite{bucur14,K76,luckow14}, incomplete databases~\cite{AG85, IL84a, pip10, lenses15}, program slicing~\cite{W81}, and expressive provenance models~\cite{AD11d}.
Symbolic execution has been used extensively in software testing~\cite{cadar13}.
Cosette~\cite{chu2017} is an automated prover for checking equivalences of SQL queries which converts input queries to constraints over symbolic relations.
\cite{zhou-19-autvqequssm} use a symbolic representation of a query result to prove two queries to be equivalent using an SMT solver~\cite{moura-11-smt}.
Rosette~\cite{torlak2014} is a
language for building DSL with built-in support for symbolic evaluation.
The transaction repair approach from~\cite{dashti17} also detects dependencies between update operations like our optimized program slicing technique for single modifications. However, transaction repair operates on concrete data while we reason about the interactions of updates for a set of inputs encoded compactly as VC-tables.

%
%
%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%%%%%%%%%%
%
%


%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "historical_whatif"
%%% End:
