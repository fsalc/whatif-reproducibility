\section{Optimized Program Slicing for Single Modifications}
\label{sec:optim-progr-slic}

Based on the VC-databases created by this step we then determine a static slice. We introduce a condition called \textit{dependency} that can be checked over the VC-database and determines whether an update's result depends on the modification $\deltaHist$. As we will demonstrate, the set of dependent updates from $\history$ ($\history(\deltaHist)$) is a static slice for the historical what-if query $\hwhatif$.

Observe that a statement can be excluded from reenactment if none of the tuples affected by the statement will be in the difference between $\history$ and $\history[\deltaHist]$. Note that any tuple in the difference has to be affected by at least one of the statements modified by a modification $\modi \in \deltaHist$, because a tuple that is not affected by any statement from $\deltaHist$ will be the same in $\history$ and $\history[\deltaHist]$ and, thus, cannot be in the result of $\hwhatif$.

Conversely, an update has to be included in a static slice if there exists at least one database $\db$ that contains a tuple which is affected by the statement and which is in the result of $\hwhatif$ over $\db$.

% Then to test for an update $u_i$ whether it should be included in $\depOver(\history, \deltaHist)$ we need to check whether there exists a database $\db$ where $u_i$ is in $\depUp(\history, \deltaHist, \db)$.
% which implies that there exists a tuple in $t \in \db$
%Recall that $u_i \in \depUp(\history, \deltaHist, \db)$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{defi}
Let $\history$ be a history and $\history[\deltaHist]$ be a modified history, $t$ be a tuple in the relation, and $u_{old}$ be an unmodified update and $u_{new}$ the corresponding modified update for any modification $m \in \deltaHist$. Let $t_i$ be the tuple at $\history_i(t)$ ($\ahmod_i(t)$). Let $\pos(u)$ be the position of update $u$ in $\history$. We define the following condition for exclusion from a non-minimal slice of the history:
\begin{align*}
\exclusion{H}{\deltaHist}{u_i} =\ &\forall m \in \deltaHist \neg\exists \varAssign \exists t \in \db_{\history[\deltaHist], \pos(u_m)}\\
&(\cond_{u_{orig}}(\varAssign(t_{\pos({u_{m}})})) \land \cond_{u_{i}}(\varAssign(t_{i-1})))\\
&\lor (\cond_{u_{new}}(\varAssign(t_{\pos({u_{m}})})) \land \cond_{u_{i}}(\varAssign(t_{i-1})))
\end{align*}
\end{defi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We use VC-Tables for symbolic execution of update operations and determining dependency of updates on  modifications by the historical what-if queries. Independent updates can be excluded from reenactment as their output is the same in $\history$ and $\history[\deltaHist]$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%symbolic execution of an update \FC{Beginning of sentence?}
%An update $u$ over a VC-table results in two tuples in the resulting VC-table for every tuple. One tuple is the result of $u$ updating the original tuple, while the other tuple is the unmodified version. For the modified tuple, $u$ applies $\pset_u$ over the tuple conjuncts $\cond_u$ with the previous $\cond_R(t)$, therefore $\cond=\cond_u \wedge \cond_R(t)$. For the unmodified tuple, it retains the variables and values as before, and conjuncts $\neg\cond_u$ with the previous $\cond_R(t)$, i.e. $\cond=\neg\cond_u \wedge \cond_R(t)$.


We can determine dependent updates in the history by generating VC-tables for each $u$ and $ u'$ whereas $m = u \gets u'$ and $m \in \deltaHist$. Then, we apply symbolic execution on these VC-tables for the remaining updates in the history. For each examined update ($u_i$), if we can generate a possible word for a tuple that is modified either by both $u_i$ and $u$ or $u_i$ and $u'$, $u_i$ is a dependent update. Since, a possible world shows there is a possibility that a tuple was modified by the historical what-if query and the examined update which must be considered in the answer of the the historical what-if query.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exam}
In order to detect dependent update in \Cref{fig:running-vctb}, we examine generating a possible world for a tuple in the VC-Table that is modified by both the first ($u_1$) and the second update ($u_2$) in the history in \Cref{fig:Transitive-Transactions-Example}.
 After symbolic execution of the second update where $\cond:= x_{Country}=UK \wedge x_{Price} <=100$, there are four tuples in the VC-Table. The first tuple which has the conditional function
 $x_{Price} >=40 \wedge (x_{Country}=UK \wedge x_{Price} <=100)$ representing it is modified by both updates. The possible world can be generated by evaluating $(x_{Country} \leftarrow UK,x_{Price} \leftarrow 40,x_{ShippingFee} \leftarrow 5)(x_{Price}>=40 \wedge (x_{Country}=UK \wedge x_{Price} <=100))$. As $40>=40 \wedge (UK=UK \wedge 40 <=100):= true$. The possible world $\world''$ after executing the first and second update statements can be $\world''=\lbrace UK,40,5\rbrace$. So, the second update is dependent on the first update as it is possible that  a tuple is modified by both updates.
\end{exam}
\FC{Update example to use global conditions?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{theo}
%We can detect dependent updates by using symbolic execution for updates in the history and checking for a possible world that can be generated for a tuple in the VC-Table that is modified by both $\deltaHist$ and the examined update in the history.
Consider a historical what-if query $\hwhatif = \ahwhatif$ with a single modification $\deltaHist = \{ m\}$ for $m = \up_1 \gets \up_1'$ over history $\history= u_1,\ldots,u_{n}$.
%The possible worlds for $vtb$ is $\worlds$ and $vtb'$ is $\worlds'$.
%$\pset(\cond_R(t)) = true$. It means the condition $\cond_R$ produced from $\pset$ must be $true$ to be a possible world $\world \in \worlds$.
The set $\idxs = \{ i \mid \neg \exclusion{\history}{\deltaHist}{u_i} \}$ is a slice for $\hwhatif$.
% $u_i$ may be safely excluded from any slice over $H(\worlds)$
% if the following condition holds:\\
% \resizebox{1\linewidth}{!}{
% \begin{minipage}{1.0\linewidth}
% \begin{align*}
%   \exclusion{H}{\deltaHist}{u_i}
% \end{align*}
% \end{minipage}
% }
%$\,$\\[-8mm]
\end{theo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifnottechreport{
  \begin{proofsketch}
    We prove this theorem by contradiction, showing that it is not possible for $\zeta$ to be true over a dependent update. For the full proof see \cite{techreport}.
  \end{proofsketch}
}
\iftechreport{
  \begin{proof}

\newcommand{\iex}{\idxs_{excl}}
\newcommand{\iin}{\idxs_{in}}
\newcommand{\iexi}[1]{\idxs_{excl,#1}}
\newcommand{\iini}[1]{\idxs_{in,#1}}
\newcommand{\dslicei}[1]{\Delta_{#1}}

    % We prove it by contradiction. A historical what-if query with a single modification $m = \xid.u \gets u'$, suppose there is a tuple $t \in \db$ and it does not satisfy the condition $\theta(u) \vee \theta(u')$ but it is in the result of the historical what-if query $\qResultDiff{\query}{\ract{\history}}{\ract{\history[\deltaHist]}}$. In this case, it can not be modified by either $u$ or $u'$ since it does not meet the condition of any of these updates. So, $t$ would be same in the result of $\ract{\history}$ and $\ract{\history[\deltaHist]}$ and it can not be in the result of $\qResultDiff{\query}{\ract{\history}}{\ract{\history[\deltaHist]}}$ so we can exclude this tuple and filter the input to $\ract{\history}$ and $\ract{\history[\deltaHist]}$ and
  Consider a history $\history = (u_1, \ldots, u_n)$, set of modifications $\deltaHist = \{m\}$ for $m = u_1 \gets u_1'$, and historical what-if query $\hwhatif = (\history, \db, \deltaHist)$. Let $\idxs_{in} = \{ \upPos(u_i) \mid \neg \exclusion{\history}{\deltaHist}{u_i} \}$ and $\iex = \{  \upPos(u_i) \mid \exclusion{\history}{\deltaHist}{u_i} \}$. We have to prove that $\idxs_{in}$ is a slice for $\hwhatif$. In the following let $\iexi{i}$ denote the first $i$ positions from $\iex$ and $\iini{i} = [1,n] - \iexi{i}$, i.e., from the histories all updates from $\iexi{i}$. We prove the theorem by induction over $i$. In the following we use $\Delta$ to denote $\iDiff{\history(\db)}{\ahmod(\db)}$ and $\dslicei{i}$ to denote $\iDiff{\hslice{\history}{\iini{i}}(\db)}{\hslice{\ahmod}{\iini{i}}(\db)}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{Base case:}
Consider $\iexi{1} = {j}$ for some $j \in [1,n]$. To prove that $\iini{1}$ is a slice, we have to show that $\Delta = \dslicei{1}$. For sake of contradiction assume that $\Delta \neq \dslicei{1}$. Then there has to exist a tuple $\tup$ such that (i) $\tup \in \Delta \land \tup \not\in \dslicei{1}$ or (ii) $\tup \not\in \Delta \land \tup \in \dslicei{1}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{$\tup \in \Delta \land \tup \not\in \dslicei{1}$:}
If $\tup \in \Delta$ then either $\tup \in \history(\db) \land \tup \not\in \ahmod(\db)$ or $\tup \not\in \history(\db) \land \tup \in \ahmod(\db)$. Since these two cases are symmetric, WLOG assume that $\tup \in \history(\db) \land \tup \not\in \ahmod(\db)$. It follows that $\exists \tup_{1} \in \db$ such that $\history(\tup_1) = \tup$ and $\neg \exists \tup_{1}' \in \db$ such that $\ahmod(\tup_{1}') = \tup$. Specifically, $\ahmod(\tup_{1}') \neq \tup$. Now let $\tup_i = \hslice{\history}{i}(\tup_1)$ and $\tup_i'= \hslice{\ahmod}{i}(\tup_1)$. Since $j \in \iex$, condition $\exclusion{\history}{\deltaHist}{u_j}$ has to hold which implies $\neg \theta_j(\tup_j)$ and $\neg \theta_j(\tup_{j}')$.

Now let us use $s_i$ to denote $\hslice{\history}{\iini{1} \cap [1,i]}(\tup_1)$ and $s_i'$ to denote $\hslice{\ahmod}{\iini{1} \cap [1,i]}(\tup_1)$.
Since $\hslice{\history}{j-1} = \hslice{\history}{\iini{1} \cap [1,j-1]}$ and $\hslice{\history}{j-1} = \hslice{\history}{\iini{1} \cap [1,j-1]}$, we have $t_{j-1} = s_{j-1}$ and $t_{j-1}' = s_{j-1}'$. Now since $\neg \theta_j(\tup_j)$ and $\neg \theta_j(\tup_{j}')$, $t_j = s_{j-1}$ and $t_j' = s_{j-1}'$. Furthermore, note that $\hslice{\history}{j+1,n} = \hslice{\history}{\iini{1} \cap [j+1,n]}$ and $\hslice{\ahmod}{j+1,n} = \hslice{\ahmod}{\iini{1} \cap [j+1,n]}$. Thus, it follows that $t = \tup_n = s_{n-1}$ (the sliced histories have one less update) and $\tup' = s_{n-1}'$ which contradicts $\tup \not\in \dslicei{1}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{$\tup \not\in \Delta \land \tup \in \dslicei{1}$:}
Since $\hslice{\history}{\iini{1}}$ (and $\hslice{\ahmod}{\iini{1}}$) are histories, from \Cref{theo:data-slicing} follows that if $s \in \dslicei{1}$ then $s_1 \models \theta_1 \vee \theta_1'$ ($s_i$, $t_i$, $s_i'$ and $t_i'$ are as defined above). Because we know that $\exclusion{\history}{\deltaHist}{u_j}$ we also know that $\neg \theta_j(s_{j-1})$ and $\neg \theta_j(s_{j-1}')$. Applying the same argument as for the opposite direction proven above, this implies that $s \in \Delta$ which contradicts $s \not \in \Delta$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{Induction Step:}
Assume that $\iini{i}$ is a slice for $\hwhatif$, i.e., $\Delta = \dslicei{i}$. We have to show that $\iini{i+1}$ is also a slice, i.e., $\Delta = \dslicei{i+1}$. Note that $\dslicei{i+1}$ differs from $\dslicei{i}$ only in that it excludes an additional update at a position $j$, i.e., $\iini{i+1} = \iini{i} - \{ j \}$ and $\forall l \in \iexi{i}: j > l$. Let $k = \max(\iexi{i})$. The remainder of the argument proceeds analog to the base case. For sake of contradiction assume that there exists a tuple $\tup$ with $\tup \in \Delta \land \tup \not\in \dslicei{i+1}$. Let use again employ the notation $s_i$, $s_i'$, $t_i$ and $t_i'$ as above. Then by applying the argument from the base case iteratively, we can show that $t_{j-1} = s_{j-1}$ and $t_{j-1}'= s_{j-1}'$. Together with $\exclusion{\history}{\deltaHist}{u_j}$ this implies $t_j = s_{j-1}$ and $t_{j}' = s_{j-1}'$ (again using the same argument already applied in the base case) and in turn implies $\tup \in \dslicei{i+1}$. The proof for $\tup \not\in \Delta \land \tup \in \dslicei{i+1}$ is also analog to the base case and, thus, we omit it here.

% Using the argument applied in the base case for any tuple $\tup \in \Delta$ we can show that


    % We prove this theorem by contradiction over a two update history, and extend it to histories of any length through the use of induction.\par
    % Suppose $u_1$ is an update in $\history = \{u_0, u_1\}$, where $\exclusion{H}{\deltaHist}{u_1}$ is true. $m = u_0 \gets u_0'$ is a modification where $m \in \deltaHist$. For the sake of contradiction, we say that $u_1$ is not to safe to exclude over any slice of $\history(\worlds)$ or $\history[\deltaHist](\worlds)$, i.e. $u_1 \in \depOver(\history, \deltaHist)$. Given $\exclusion{H}{\deltaHist}{u_1}$ is true, it holds that there is no tuple $t$ updated by both $u_0$ and $u_1$, or $u_0'$ and $u_1$, as there is no assignment $\varAssign$ that makes the conditions of $u_0 (u_0')$ and $u_1$ possible over any tuple. If no tuples updated by $u_0$ or $u_0'$ are also updated by $u_1$, it holds that the input tuples to $u_1$ are the same as there are no other modifications. It is supposed that $u_1 \in \depOver(H, \deltaHist)$, whose condition for determining dependency of $u_1$ implies that there is a possible world where there is a tuple that is modified by either $u_0$ and $u_1$ or $u_0'$ and $u_1$ where the resulting tuple is absent from the other set. However, $\exclusion{H}{\deltaHist}{u_1}$ necessarily means there are no tuples modified by both updates, so $u_1 \in \depOver(\history, \deltaHist)$ is impossible. That is, $u_1$ is necessarily absent from $\depOver(\history, \deltaHist)$ if $\exclusion{H}{\deltaHist}{u_1}$ is true.
    \FC{Induction Step}
    $\,$\\[-3.5mm]
  \end{proof}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{What-if Algorithm}
%\label{sec:impl-appr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%original Algo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{algorithm}[t]
%  \caption{Answering Historical What-if Query}
%  \label{alg:whatif-algo}
%  \begin{algorithmic}[1]
%    \Procedure{WhatIf}{$\history$, $\db$, $\query$, $\deltaHist$}
%    \State $dep \gets \Call{ComputeDependencies}{\history,\db, \deltaHist}$
%    \State $\ract{\history} \gets \Call{GenReenactmentQuery}{\history,dep}$
%    \State $\ract{\history}^{*} \gets \Call{ApplyDataSlicing}{\deltaHist,\ract{\history}}$
%    \State $\ract{\history[\deltaHist]} \gets \Call{GenReenactmentQuery}{\history[\deltaHist],dep}$
%    \State $\ract{\history[\deltaHist]}^{*} \gets \Call{ApplyDataSlicing}{\deltaHist,\ract{\history[\deltaHist]}}$
%    \State \Return $\Call{SymmetricDiff}{\query,\ract{\history}^{*},\ract{\history[\deltaHist]}^{*}}$
%    \EndProcedure
%  \end{algorithmic}
%\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%modified Algo

% shows the Function $ComputeDependencies$ identifies all update statements in $\history$ that are depend on the modification $\modi = \xid.u_i \gets u$ and $dep$ includes all dependent update that should be considered for reenactment. After generating reenactment query $\ract{\history}$ for all dependent update and the original update statement $u_i$ by the Function $Reenact$, the $DataSlicing$ Function changes $\ract{\history}$ to $\ract{\history}^{*}$ that filters the input data based on the input data for $u_i$. The same process is defined for the modified update statement $u$. In the last line, the $\query$ over both $\ract{\history}^{*}$ and $\ract{\history[\modi]}^{*}$ is evaluated and their symmetric difference is computed and it returns the generated SQL query as the result.\\
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Our algorithm to the historical what-if query is based on MV-semirings model and using reenactment. It includes three main steps:\textbf{1)} retrieving information about related updates \textbf{2)} filtering update operations of transactions based on dependency rules \textbf{3)} translating detected dependent updates and applying reenactment \textbf{4)} filtering input data of reenactment queries \textbf{5)} compute the final answer by determining the symmetric difference of query $\query$ over the reenactment queries. To implement our algorithm, we use time travel and audit logs, two features that are supported by most of DBMS (e.g., Oracle, DB2, SQLServer). Time travel gives an access to the past database snapshots and audit logs contains information about history of SQL statements such as when they were executed, and as part of which transaction. We explain each step of the algorithm in following subsections.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Retrieving Information}
% \label{def:retrieve-info}
% In the first step, we should retrieve information about the what-if query and other update statement that might be depend on the what-if query by querying audit logs. In particular, we need to know what was the original SQL statement and all other update statement that were executed by the same transaction, when each statement was executed, which statements were executed after the what-if query by other transactions, and what concurrency control protocol were used for execution of these transactions.
% %We must retrieve information based on the applied concurrency control protocol and execution time of each  statement of other transaction.
% %The following rules are defined for transactions that were executed under SI.
% %Assume the what-if statement must be executed as a part of the transaction $\xid$ and $\xid_i \sqsubseteq \xid_0, \ldots, \xid_n$ are belongs to the history $\history$,
% In overall, following SQL statements and their related information are required to be retrieved.
% \begin{itemize}
% \item $u_1, \ldots, u_n$ where $\xid = (u_1, \ldots, u_n, c)$ and $\modi = T.u_i \gets u$
% \item $\forall u_j \in H$ where $1 \leq i < j \leq n \wedge u_i \hSorder u_j$
% %Retrieve $u_0, \ldots, u_m$ of the transaction $\xid_i$ where $End(\xid) < Start(\xid_i)$ and these transactions executed under SI. This means all update statement of the transaction $\xid_i$ must be retried
% %as the start time of Transaction $\xid_i$ is greater than the end time or the commit time of the Transaction $\xid$
% %because $\xid_i$ sees a  snapshot of the database containing all changes of the transaction $\xid$.
% \end{itemize}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Dependency Rules}
% \label{def:basic-rules}
% We can check basic rules to approximate the dependency of update statement of transactions based on the \Cref{def:dependency1} without replaying concurrent transactions. Lets $R$ be a set of tables that are modified by $u$ or $u_i$ where $\modi = T.u_i \gets u$ and $u_j$ is a retrieved update statement from the previous step.
% %it is possible Transaction $\xid_i$ depends on $\xid$.
% %\item \textbf{Checking Tables:} $(Write(\xid) \cap Write(\xid_i)\neq \emptyset) \vee (Write(\xid) \cap Read(\xid_i)\neq \emptyset)$  whereas $Write$ are set of tables that are modified or written by a transaction and $Read$ are set of tables that a transaction reads from them. This rule is beneficial for update and delete statements. However, for insert statements transitivity should be checked.
% \begin{itemize}
% \item \textbf{Checking Tables:} $(R \cap Write(u_j)\neq \emptyset) \vee (R \cap Read(u_j)\neq \emptyset)$  whereas $Write$ are set of tables that are modified or written by $u_j$ and $Read$ are set of tables that a $u_j$ reads from them. This rule is beneficial for update and delete statements. However, for insert statements transitivity should be checked.
% \item \textbf{Analyzing Effect of Updates:} Our algorithm must analyze effect of the what-if query and its respective original update statement on $u_i$
% %other update statements
% by evaluating their value assigns and condition sets. The following example shows how analyzing effect of an update can help to detect dependent updates.
% % Let $\theta_1$ be a condition set of an update statement before change and $\theta_1'$ be a condition set of an update statement after change (condition set of a whatif query). Suppose we want to check the dependency of this update with another update statement which has a condition set $\theta_2$. the dependency is true if : $(\theta_1 \wedge \theta_2)\vee(\theta_1'\wedge \theta_2)$ is true.
% \end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THIS IS OUTDATED I THINK
% % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{algorithm}[t]
%   \caption{Compute Dependencies}
%   \label{alg:depend-algo}
%   \begin{algorithmic}[1]
%     \Procedure{ComputeDependencies}{$\history$, $\db$, $u$}
% %    \State $depList \gets NULL$
%     \State $\symIns{0} \gets \Call{InitSymbolicIns}{\history,\db}$
%     \State $\symIns{1} \gets \symExe{0}{0}$  \Comment{$\history[0]= u$}
%     \State $\symIns{1} \gets \symCond{0}{1}$
%     \State $depList \gets u$
%     \For{$i \gets 1, \history.length-1$}
%     \If{$\symCond{i}{i}$}
%     \State $depList \gets \history[i]$
%     \EndIf
%     \State $\symIns{i+1} \gets \symExe{i}{i}$
%     \EndFor
%     \State \textbf{return} $depList$
%     \EndProcedure
%   \end{algorithmic}
% \end{algorithm}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \Cref{alg:depend-algo} shows how we implement detecting dependent updates. It first initialize the symbolic instance (VC-table).
% % which is presented in detail in \Cref{alg:init-algo}.
% The next state for this symbolic instance is generates based on symbolic execution of update statements in the $\history$. Note that $\history$ contains $u$ and update statements which were executed after $u$ and $\history[0]$ equals to $u$.
% $\symIns{i+1} \gets \symExe{i}{i}$ implement symbolic execution of the update statement which is discussed in the \Cref{sec:sym-lin}. $\symCond{i}{i}$ checks whether the condition of the update statement $\history[i]$ is mutual satisfiable with the condition of the first update $\history[0]$ that was applied in $\symIns{1} \gets \symCond{0}{1}$. In the following section.  We propose a method which uses a constraint programming formulation expressing symbolic execution of update statements as a mixed integer linear program (MILP).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{algorithm}[t]
%  \caption{Create Symbolic Instance}
%  \label{alg:init-algo}
%  \begin{algorithmic}[1]
%    \Procedure{InitSymbolicIns}{ $\db$, $u$}
%    \State $tbName \gets \Call{getTableName}{u}$
%    \State $i \gets 0$
%    \ForAll{$\attr{j} \in \Call{getSchema}{\db,tbName}$}
%    \State $X[i] \gets x_{\attr{j}}$
%    \State $i \gets i+1$
%    \EndFor
%    \State \textbf{return} $X$
%    \EndProcedure
%  \end{algorithmic}
%\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Cref{alg:init-algo} generates variables for each attribute of the table that was affected by the update statement $u$.  It first calls \texttt{getTableName} function which return the name of the tables that was affected by the update statement. Then \texttt{getSchema} returns schema information of that table. Finally, for all attributes $\attr{j}$ of the table a new variable $x_{\attr{j}}$ is generated and the set of variables will be return as a symbolic instance.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "techreport"
%%% End:
