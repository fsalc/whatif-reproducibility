\section{Slicing with Symbolic Execution}
\label{sec:sym-exe}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We adapt concepts from incomplete databases~\cite{IL84a} to reason about the behavior of updates over a set of possible databases represented by a compressed database. This is akin to \textit{symbolic execution}~\cite{cadar13,K76} which is used in software testing to determine inputs that would lead to a particular execution path in the program.
%
We use \textit{Virtual C-tables}~\cite{pip10,lenses15} (\textit{VC-tables}) as a compact representation of the set of possible worlds represented by a compressed database (to be discussed in \Cref{sec:compr-input-datab}) and demonstrate how to evaluate updates with possible worlds semantics over such representations. That is, the result of a history over a VC-table instance encodes all possible results of the history over every possible world represented by the VC-table. Using a constraint solver, we can then prove existential or universal statements over these possible results. Specifically, we will check that a candidate slice and the full histories produce the same result for a \abbrHW $\hwhatif$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Incomplete Databases and Virtual C-Tables}
\label{sec:vc-tb}
An incomplete database $\worlds = \{ \world_1, \ldots, \world_n \}$ is a set of deterministic databases called possible worlds. Each $\world_i$ represents one possible state of the database. Queries (and updates) over an incomplete database $\worlds$ are evaluated using possible world semantics where the result of the query (statement) is the set of possible worlds derived by applying the query (statement) to every possible world from $\worlds$: % for a query $\query$ and incomplete database $\worlds$ we have
%
$$\query(\worlds) = \{ \query(\world) \mid \world \in \worlds \}$$
%
For our purpose, it will be sufficient to use an incomplete database consisting of possible worlds containing a single tuple, because we restrict program slicing to tuple independent statements which process every input tuple independent of every other input tuple.
%
This incomplete database contains one world for any such singleton relation.
We then evaluate updates from the original and modified history and their slices over this incomplete database and search for worlds where the delta for the full histories is different from the delta for the slice.
\iftechreport{However, the number of possible tuples per relation (and, thus, also the number of possible worlds) is exponential in the number of attributes of the relation. For instance, consider a relation with $n$ attributes and a domain with $m$ values. Then there are $m^n$ possible tuples for this relation that we can construct using the values of the domain.}
For efficiency we need a compact representation of an incomplete database. We employ Virtual C-tables~\cite{pip10,lenses15} which extend C-tables~\cite{IL84a} to support scalar operations over values.

A VC-table $\vcrel$ is a relation with tuples whose values are symbolic expressions over a countable set of variables $\varDom$ and where each tuple $\vct$ (we use boldface to indicate tuples with symbolic values) is associated with a condition $\lcond(\vct)$ (the so-called \textit{local condition}). The grammar shown in \Cref{fig:expr-grammar} defines the syntax of valid expressions. A VC-database $\vcdb$ is a set of VC-tables paired with a condition $\gcond$, called a global condition. Let $\dataDomain$ denote a universal domain of values.
A VC-db $\vcdb$ encodes an incomplete database which consists of all possible worlds that can be generated by assigning a value to each variable in $\varDom$, evaluating the symbolic expressions for each tuple in $\vcdb$ and including tuples in the possible world whose local condition $\lcond(\vct)$ evaluates to true. Only assignments for which the global condition $\gcond$ evaluates to true are part of the incomplete database represented by $\vcdb$.
We use $\worldsOf{\vcdb}$ to denote the set of worlds encoded by the VC-database $\vcdb$ (and apply the same notation for VC-tables). For ease of presentation, we will limit the discussion to databases with a single relation and for convenience associate a global condition with this single relation (instead of with a VC-database). However, our method is not subject to this restriction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{defi}[$\worldsOf{\vcdb}$]\label{def:vcdb-worlds}
  Let $\vcdb$ be a VC-db and let $\allVarAssigns$ be the set of all assignments $\varDom \to \dataDomain$.
  \begin{align*}
\worldsOf{\vcdb} &= \{ \db \mid \exists \varAssign \in \allVarAssigns: \varAssign(\vcdb) = \db \land \varAssign(\gcond)\}
  \end{align*}
Abusing notation, we apply $\varAssign$ to VC-dbs, tuples, and symbolic expressions $\expr$ using the semantics defined below.
  \begin{align*}
\varAssign(\vcdb) &= \{ \varAssign(\vct) \mid \vct \in \vcdb \land \varAssign(\lcond(\vct)) \}
  \end{align*}
  \begin{align*}
        \varAssign(\expr_1 \diamond \expr_2) &= \varAssign(\expr_1) \diamond \varAssign(\expr_2) \,\,\,\text{\textbf{for}}\,\, \diamond \in \{+,-,\cdot,\div,=,\neq,<,\leq,>,\geq,\land,\lor\}\\
        \varAssign(\diamond \expr_1) &= \diamond \varAssign(\expr_1)
    \,\,\,\text{\textbf{for}}\,\, \diamond \in \{\neg, \isnull\}
  \end{align*}\\[-9mm]
  \begin{align*}
    \varAssign( (\expr_1, \cdots, \expr_n)) &= (\varAssign(\expr_1), \cdots, \varAssign(\expr_n))     &\varAssign(\T) &= \T  \\
        \varAssign(\sqlCase{e_1}{e_2}{e_3}) &=
                                          \begin{cases}
                                            \varAssign(e_2) &\mathbf{if}\,\,\varAssign(e_1)\\
                                            \varAssign(e_3) &\mathbf{otherwise}\\
                                          \end{cases}
    &\varAssign(\F) &= \F\\
  \end{align*}
\end{defi}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exam}
\label{ex:pw-example}
Consider relation \texttt{Order} from \Cref{ex:running-example}. In this example, we just consider the three attributes that are used by updates in the history (\texttt{Country}, \texttt{Price}, \texttt{ShippingFee}).
A VC-table over this schema is shown on the top left in \Cref{fig:running-vctb}. This VC-table contains a single tuple with three variables $x_{Country}$, $x_{Price}$, and $x_{ShippingFee}$ and a local condition $\T$ (shown on the right of the tuple). Consider the variable assignment $x_{Country} = UK$, $x_{Price} = 10$, and $x_{ShippingFee} = 0$. Applying this assignment, we get the  possible world  $\{(UK, 10, 0)\}$.
%
%
\end{exam}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifnottechreport{We will show in \Cref{sec:compr-input-datab} how to encode information about the data distribution of the database of a \abbrHW as part of the global condition of an VC-database.} %
\iftechreport{Note that we can encode information about the data distribution of the database of a \abbrHW as part of the global condition of a VC-database. For instance, we can compress the Order relation from \Cref{fig:running-example-instance} into a conjunction of range constraints. The set of tuples fulfilling this condition is a superset of the Order relation.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align*}
  x_{Country} \in \{UK,US\} \land x_{Price} \geq 20 \land x_{Price} \leq 60 \\
  \land x_{Shipping Fee} \geq 3 \land x_{ShippingFee} \leq 5
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Updates on VC-Tables}
\label{sec:up-vc-tb}
%
%
%
%
%
Prior work on updating incomplete databases (e.g., \cite{fagin-86-upld,winslett-86-upldcnv,AG85}) does not support VC-tables. For our purpose, we need to be able to evaluate statements over VC-tables with possible world semantics. That is, the possible worlds of  the result of applying a statement  to a VC-table are derived by computing the statement over every possible world of the input.
%
For an insert $\ainsert$ we just add the concrete tuple $\tup$ with a local condition $\lcond(t) = \T$ to the input VC-table $\vcrel$.
%
For a delete $\delete{\cond}$, for some assignment $\varAssign$, the concrete tuple $\varAssign(\vct)$ derived from a  symbolic tuple $\vct \in \vcrel$ is deleted by the statement if the tuple's local condition evaluates to true $\varAssign(\lcond(\vct)) \models \T$ and the tuple does not fulfill condition $\cond$ ($\varAssign(\vct) \not\models \cond$). We can achieve this behavior by setting the local condition of every tuple $\vct$ to $\lcond(\vct) \land \neg \cond(\vct)$. The symbolic expression $\cond(\vct)$ is computed by substituting any reference to attribute $A$ in  $\cond$ with the symbolic value $\vct.A$.
%
An update $\aupdate$ can affect a tuple $\vct$ in a VC-table in one of two ways in each possible world ($\varAssign$): (i) either the update's condition evaluates to false and the values of $\varAssign(\vct)$ are not modified or (ii) the update's condition evaluates to true on $\varAssign(\vct)$ and $\pset$ is applied to the values of $\varAssign(\vct)$. We have to provision for both cases.

\iftechreport{
One way to encode this is to return two tuples for every input tuple $\vct$: one tuple with updated local condition that ensures that $\vct$ is only included if $\cond$ evaluates to false on $\vct$ and another tuple $\pset(\vct)$ with a location condition that ensures that $\pset(\vct)$ is only included if $\cond$ evaluates to true. Note that there may exist multiple input tuples $\vct$, $\vct'$, $\vct''$, \ldots which are all projected onto the same output, i.e., there exists $\vct_{out}$ such that $\vct_{out} = \pset(\vct) = \pset(\vct') = \ldots$. Tuple $\vcOf{t_{out}}$ exists in the result of the update as long as $\cond$ holds for at least one of these inputs. That is the local condition of $\vcOf{t_{out}}$ is a disjunction of conditions $\lcond(\vct) \wedge \cond(\vct)$ for any input $\vct$ where $\pset(\vct) = \vcOf{t_{out}}$. Note that we can simplify the resulting instance by evaluating constant subexpressions in symbolic expressions and by removing any tuple $\vct$ for which $\lcond(\vct) \equiv \F$.
Observe that in the worst-case evaluating a sequence of $n$ updates over a VC-table can lead to an instances that is $2^{n-1}$ times larger than the input since we generate two output tuples for each input tuples in the worst case (if no two inputs are projected onto the same symbolic output).
}
\ifnottechreport{
One option is to encode each case as a separate output tuple, but this would result in an exponential blow-up of the number of tuples since each update in a history would double the number of tuples (because it produces two output tuples for each input tuple).}
We can avoid this exponential blow-up by introducing tuples with fresh variables to represent the updated versions of tuples and by assigning values to these new variables using the global condition.
We show these semantics for statements below. To ensure that there are no name clashes between variables, we generate fresh variables $\{x_{\vct,A_i}\}$ to represent the value of attribute $A_i$ of the tuple produced by applying the statement to tuple $\vct$ from the input VC-table. % as values for the updated version of a tuple $\vct$.
% We formally define updates below.
We use $\lcond(\vcrel,\vct)$ to denote the local condition of tuple $\vct$ in relation $\vcrel$ and for convenience  define $\lcond(\vcrel,\vct) = \F$ for any $\vct \not\in \vcrel$. \BG{repeated: Furthermore, $\cond(\vct)$ for update $\update{\pset}{\cond}$ and tuple $\vct$ denotes the result of substituting references to attributes in $\cond$ with their value in $\vct$.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{defi}[Updates over VC-tables]
  Let $\vcrel$ be a VC-table and $\schema{\vcrel} = (A_1, \ldots, A_n)$. Update statements over VC-tables are defined as shown below. % Note that for any update statement $\up$ we define $\gcond(\up(\vcrel)) = \gcond(\vcrel)$.
Let  $\pset = (e_1, \ldots, e_n)$. Given a tuple $\vct$, we use  $\vctn$ to denote $(x_{\vct,A_1}, \ldots, x_{\vct,A_n})$.
  \begin{align*}
    \update{\pset}{\cond}(\vcrel)   &= \{ \vctn \mid \vct \in \vcrel \}
    &\lcond(\update{\pset}{\cond}(\vcrel), \vctn )  &= \lcond(\vcrel,\vct)
  \end{align*}
  \begin{align*}
    &\gcond(\update{\pset}{\cond}(\vcrel)) = \gcond(\vcrel) \land \bigwedge_{\vct \in \vcrel} \bigwedge_{i=1}^{n} x_{\vct,A_i} = \sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i}
    \end{align*}
  \begin{align*}
    \delete{\cond}(\vcrel)                & = \{ \vct \mid \vct \in \vcrel \}                                                                                                                                 &
    \lcond(\delete{\cond}(\vcrel), \vct) &= \lcond(\vcrel, \vct) \land \neg \cond(\vct)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \end{align*}
  \begin{align*}
    \ins{t}(\vcrel)                        & = \vcrel \union \{ t \}                                                                                                                                &
\lcond(\ins{t}(\vcrel),t)  &= \T
    & \lcond(\ins{t}(\vcrel),\vct) &= \lcond(\vcrel,\vct) \tag{for $\vct \neq t$}
  \end{align*}\\[-9mm]
  \begin{align*}
        \gcond(\ins{t}(\vcrel)) = \gcond(\adelete(\vcrel)) = \gcond(\vcrel)
  \end{align*}
\end{defi}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
Using these semantics, the result of a sequence of $n$ statements over a relation with $m$ attributes has the same number of tuples as the input and the number of conjuncts in the global condition is bound by $n \cdot m$. Furthermore,
each conjunct is of size linear in the size of the expressions of the statements ($\cond$ or $\pset$).
\iftechreport{Note that we can reduce the number of variables in an updated VC-table, by reusing variables for attributes that are not affected by an update.} For our use case we execute a sequence of statements over an instance with a single tuple. Thus, it will be convenient to use a different naming schema for variables. We use $x_{A,i}$ to denote the value of attribute $A$ of the version of this single input tuple after the $i^{th}$ update.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[t]
  \centering
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.25\linewidth}
    \footnotesize
    \begin{tabular}{|c|c|c|l}
        \thead{Country} & \thead{Price} & \thead{ShippingFee} &  \\ \cline{1-3}
            $x_{Country}$ & $x_{Price}$ & $x_{ShippingFee}$ & $\T$ \\ \cline{1-3}
    \end{tabular}
    \[\gcond = \T\]
      \caption{Initial VC-database $\vcdbini$.}\label{fig:initial-vc-table}
    \end{subfigure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.7\linewidth}
     \centering
    \footnotesize
        \begin{tabular}{|c|c|c|l}
        \thead{Country} & \thead{Price} & \thead{ShippingFee} &  \\ \cline{1-3}
            $x_{Country}$ & $x_{Price}$ & $x_{ShippingFee,2}$ & $\T$ \\ \cline{1-3}
        \end{tabular}
        \begin{align*}
          \gcond &\defas \gcond_1 \land \gcond_2 % (x_{Country,1} = x_{Country})\\
                 % &\wedge (x_{Price,1} = x_{Price})\\
                 \hspace{2cm}\gcond_1 \defas (x_{ShippingFee,1} = \sqlCase{x_{Price} \geq 50}{0}{x_{ShippingFee}})\\
                 % & \wedge (x_{Country,2} = x_{Country,1})\\
                 % & \wedge (x_{Price,2} = x_{Price,1})\\
                 & \gcond_2 \defas (x_{ShippingFee,2} = \sqlCase{(x_{Country} = UK \wedge x_{Price} \leq 100)}{x_{ShippingFee,1} + 5}{x_{ShippingFee,1}})
        \end{align*}\\[-3mm]
      \caption{VC-table after evaluating $\history = (u_1, u_2)$.}
   \end{subfigure}\\[-3mm]
  \caption{Running example for evaluating updates over VC-Tables.}
  \label{fig:running-vctb}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exam}\label{ex:up-vctb}
  %
Continuing with \Cref{ex:pw-example}, consider the first two updates from \Cref{fig:Transitive-Transactions-Example} (we abbreviate attribute names as in previous examples): $u_1 = \update{F \gets 0}{P \geq 50}$  % with $\cond \defas Price >=40$ and $\pset \defas (ShippingFee \gets 0)$
and $\up_2 = \update{F \gets F + 5}{C = UK \land P \leq 100}$. % $\cond \defas country = UK \land price \leq 100$ and $\pset \defas (ShippingFee \gets ShippingFee + 5$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
After execution of $u_1$ and $u_2$ over $\vcdbini$ shown in \Cref{fig:initial-vc-table}, we get an instance with a single tuple. Since both updates only modify attribute \texttt{ShippingFee}, all other attributes can reuse the same variable as in the input.  % (the values of these attributes are not affected in any possible world).
The value of attribute \texttt{ShippingFee} is a new variable $x_{ShippingFee,2}$ which is constrained by the global condition that ensures that it is equal to the previous value of this attribute ($x_{ShippinFee,1}$) if the condition of $u_2$ does not hold and otherwise is the result of applying  $\pset_{\up_2}$ to $x_{ShippingFee,1}$. Furthermore, $x_{ShippingFee,1}$ is related to the value of attribute \texttt{ShippingFee} in the input in the same way using a conditional expression based on $u_1$'s condition and update expression (setting the shipping fee to $0$ if the price is at least $50$).
%
%
%
%
%
\end{exam}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We now prove that our definition of  update semantics for VC-tables complies with possible world semantics. % That is, for

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{theo}\label{theo:vc-updates-are-possible-worlds-semantics}
  Let $\vcdb$ be a VC-database and $\up$ a statement. We have:\\[-5mm]
  \begin{align*}
    \worldsOf{\up(\vcdb)} = \up(\worldsOf{\vcdb})
  \end{align*}
\end{theo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifnottechreport{
  \begin{proofsketch}
    Using the definitions of $\worldsOf{\vcdb}$ and $\varAssign(\vcdb)$, we demonstrate equivalence over updates, inserts, and deletes. Note that $\varAssign$ factors through expressions (conditions $\cond$ and $\pset$ for updates) which we exploit to prove that any assignment $\varAssign$ that corresponds to a possible world of the input  can be extended into an assignment $\varAssign'$ over the update's result such that: (i) $\varAssign'$ fulfills the global condition for the updated database and (ii) $\varAssign'$ assigns through the global condition to each variable appearing in tuples in this database the values from the tuple(s) produced by evaluating the update over the possible world $\varAssign(\vcdb)$. The full proof is shown in \cite{techreport}.
  \end{proofsketch}
}
\iftechreport{
\begin{proof}\BG{Still needs to be checked}
  WLOG consider an assignment $\varAssign$ to the variables in $\Sigma$  and let $\db_{\varAssign} = \varAssign(\vcdb)$ denote the possible world corresponding to this assignment. Furthermore, observe that in both the VC-database as well as in $\db_{\varAssign}$, applying a statement $\up$ to the input database does only modify the relation $\rel$ ($\vcrel$) affected by $\up$. Thus, it is sufficient for us to reason only about this relation. We will show that $\varAssign(\up(\vcrel)) = \up(\rel_{\varAssign})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{Insert $\up = \ins{\tup}$:}
Note that $\gcond(\up(\vcrel)) = \gcond(\vcrel)$ and $\varAssign(\gcond(\vcrel)) = \T$ because $\rel_{\varAssign}$ is a possible world of $\vcrel$. Thus, we have $\varAssign(\gcond(\up(\vcrel))) = \T$ and $\varAssign(\up(\vcrel))$ is a possible world of $\up(\vcrel)$.
We have $\up(\vcrel) = \vcrel \union \{ \tup \}$. Note that $\varAssign(\vcrel)$ is defined as applying $\varAssign$ to each tuple $\vct \in \vcrel$. Furthermore, by definition $\lcond(\up(\vcrel),\tup) = \T$.
Thus, $\varAssign(\vcrel \union \{ \tup \}) = \varAssign(\vcrel) \union \{ \tup \} = \rel_{\varAssign} \cup \{ \tup \} = \up(\varAssign(\vcrel))$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{Delete $\up = \adelete$:}
%
For the same reason as for inserts, $\varAssign(\up(\vcrel))$ is a possible world of $\up(\vcrel)$.
Substituting the definition of deletes, we get $\adelete(\rel_{\varAssign}) = \{ \tup \mid \tup \in \rel_{\varAssign} \land \neg \cond(\tup) \}$. For the VC-table, we get $\adelete(\vcrel) = \{ \vct \mid \vct \in \vcrel \}$ and $\lcond(\adelete(\vcrel), \vct) = \lcond(\vcrel, \vct) \land \neg \cond(\vct)$. WLOG consider a tuple $\tup \in \rel_{\varAssign}$ and a tuple $\vct \in \vcrel$ such that $\varAssign(\vct) = \tup$ and $\varAssign(\lcond(\vcrel, \vct))$. At least one such tuple $\vct$ has to exist, because otherwise $\tup$ would not exist in $\rel_{\varAssign}$. We have to show that $\varAssign(\lcond(\adelete(\vcrel), \vct))$ holds. % \Leftrightarrow \cond(\tup)$.
Note that based on the definition of the application of an assignment to an expression, we can push $\varAssign$ through expressions, e.g., $\varAssign(e_1 \land e_2) = \varAssign(e_1) \land \varAssign(e_2)$. Thus,
%
\begin{align*}
  &\varAssign(\lcond(\adelete(\vcrel), \vct))
  = \varAssign(\lcond(\vcrel, \vct) \land \neg \cond(\vct))
  = \varAssign(\lcond(\vcrel, \vct)) \land \varAssign(\neg \cond(\vct))\\
  = &\T \land \neg \cond(\varAssign(\vct))
  = \neg \cond(\varAssign(\vct))
  = \neg \cond(\tup) = \T
\end{align*}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{Update $\up = \aupdate$:}
%
Note that any tuple $\vct$ in $\up(\vcrel)$ is not in $\vcrel$ and all variables $\vct$ do not occur in any tuple, local condition, or global condition in $\vcrel$. Since these variables do not occur in $\vcrel$, any assignment $\varAssign$ such that $\varAssign(\vcrel) = \rel_{\varAssign}$ can be extended to an assignment $\varAssign'$ over $\up(\vcrel)$ by assigning values to these fresh variables. Furthermore, recall that these fresh variables are only constrained in the global condition of $\gcond(\up(\vcrel))$. We will first show that for each $\varAssign$ such that $\varAssign(\gcond(\vcrel))$ holds, there exists one and only one extension $\varAssign'$ of $\varAssign$ such that $\gcond(\varAssign'(\up(\vcrel)))$ holds. Intuitively this means that for every world in the input there exists exactly one corresponding world in the output $\up(\vcrel)$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{Unique extension of $\varAssign$:}
Note that for each tuple $\vct \in rel$, $\up(\vcrel)$ contains a tuple $\vctn = (x_{\vct,A_1}, \ldots, x_{\vct,A_n})$ where each $x_{\vct,A_i}$ is a fresh variable and $\lcond(\up(\vcrel),\vctn) = \lcond(\up(\vcrel),\vct)$. Recall that

\begin{align}
  \label{}
\gcond(\update{\pset}{\cond}(\vcrel)) = \gcond(\vcrel) \land \bigwedge_{\vct \in \vcrel} \bigwedge_{i=1}^{n} x_{\vct,A_i} = \sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i}
\end{align}

Consider an assignment $\varAssign$ for $\vcrel$ such that $\varAssign(\gcond(\vcrel))$ holds. Since $\gcond(\update{\pset}{\cond}(\vcrel))$ is a conjunction of $\varAssign(\gcond(\vcrel))$ with constraints for each tuple $\vct \in \vcrel$, to prove our claim, it suffices to show that for any such $\vct$ and attribute $A_i$, there exist a unique assignment of $x_{\vct,A_i}$ that satisfies $x_{\vct,A_i} = \sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i}$ given $\varAssign$. As explained above we can push $\varAssign$ through expressions. Thus,

\[
  \sqlCase{\cond(\vct)}{e_i(\vct)}{\varAssign(\vct.A_i)} = \varAssign(\sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i})
\]

Note that $\varAssign(\sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i})$ is a concrete value. It follows that we can only make the equality true by setting $x_{\vct,A_i} = \varAssign(\sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i})$. Since there is a unique assignment for each $\vct.A_i$ for all $\vct \in \vcrel$ and attribute $A_i$ such that the corresponding conjunct in $\gcond(\up(\vcrel))$ evaluates to true, there exists one and only one extension $\varAssign'$ of $\varAssign$ that satisfies $\gcond(\up(\vcrel))$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\proofpar{$\varAssign'$ correctly models update semantics:}
Consider a possible world $\db_{\varAssign}$ of $\vcrel$ and let $\varAssign'$ be as established above. Consider a tuple $\vct$ and let $\tup = \varAssign(\vct)$ and $\tup_{up} = \up(\varAssign(\tup))$. Note that $\lcond(\vcrel,\vct) = \lcond(\up(\vcrel,\up(\vct)))$. Thus, $\varAssign(\lcond(\vcrel,\vct)) = \varAssign(\lcond(\up(\vcrel,\up(\vct))))$, i.e., $\vct$ exists iff $\up(\vct)$ exists.
We have to consider two cases. Either (i) $\cond(\tup)$ and $\tup_{up} = \pset(\tup)$ or (ii) $\cond(\tup)$ evaluates to false and $\tup_{up} = \tup$.

\proofpar{(i) $\cond(\tup)$ holds:}
WLOG consider attribute $A_i$. In this case $\up(\vct).A_i = \varAssign(\sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i})$ evaluates to $e_i(\varAssign(\vct)) = e_i(\tup)$ which according to the definition of updates is equal to $\tup_{up}.A_i$. Thus, $\tup_{up} = \varAssign'(\up(\vct))$.

\proofpar{(ii) $\cond(\tup)$ does not hold:}
WLOG consider attribute $A_i$. In this case $\up(\vct).A_i = \varAssign(\sqlCase{\cond(\vct)}{e_i(\vct)}{\vct.A_i})$ evaluates to $\varAssign(\vct.A_i) = \tup.A_i$ which according to the definition of updates is equal to $\tup_{up}.A_i$. Thus, $\tup_{up} = \varAssign'(\up(\vct))$.

Since we have shown that for every tuple $\tup_{up}$ we have $\tup_{up} \in \up(\varAssign(\vcrel))$ iff $\tup_{up} \in \varAssign'(\up(\vcrel))$ and $\vcrel_{\varAssign'}$ is the unique world from $\worldsOf{\up(\vcrel)}$ corresponding to $\vcrel_{\varAssign}$, we have shown that $\worldsOf{\up(\vcrel)} = \up(\worldsOf{\vcrel})$.

\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
}

Note that by induction, \Cref{theo:vc-updates-are-possible-worlds-semantics} implies that evaluating a history $\history$ over a  VC-database also has possible world semantics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Computing Slices with Symbolic Execution}\label{sec:symbolic-exe}

To compute a slice for a historical what-if query $\hwhatif = (\history, \deltaHist, \db)$  % $\depOver(\history, \deltaHist)$  for a modification $\deltaHist$ and history $\history$
where $\history$ consists of tuple independent statements only,
we create a VC-database $\vcdbini$ with a single tuple with fresh variables for each relation in the database's schema.
Even though they are tuple independent, we do not consider inserts of the form $\ainsert$ here, because, as we will show in \Cref{sec:optim-reen-hist}, we can split a reenactment query for a history with such inserts into a union of two queries --- one that is the reenactment query for the history restricted to updates and deletes and a second one that only operates on tuples inserted by inserts $\ainsert$ from the history. Since the second query only operates on an instance of size at most $\card{\history}$, its cost is too low to warrant spending time on slicing it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Compressing the Input Database}
\label{sec:compr-input-datab}

Optionally, we compress the input database $\db$ into a set of range constraints that restrict the variables of the single tuple in $\vcdbini$. For that, we decide on a number of groups and for each table select an attribute to group on. We then compute the minimum and maximum values of each non-group-by attribute $A$ for each group and use them to constrain the values of $A$ in this group. For each group we then generate a conjunction of these range constraints for each attribute. The  disjunction of the constraints generated for the groups, which we denote as $\adbconstr$, is then added to the global condition. Note that every tuple from a table of the database $\db$ corresponds to an assignment of the variables from $\vcdbini$ to the constants of the tuple that fulfills the condition. For attributes with unordered data types, we just omit the range condition for this attribute.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exam}[Compressing Databases]\label{ex:compressing-databases}
Let us compress the instance from \Cref{fig:running-example-instance}  into two tuples by grouping on \texttt{Country}. We get the following constraint that we add to the global condition to constrain the worlds of $\vcdbini$. Here, we omit the constraint for the name attribute and abbreviate attribute names as in previous examples.
%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \begin{align*}
    \adbconstr  \defas &(x_{C} = UK \land x_{ID} \in \{11,12\} \land
    % x_{Customer} \geq Alex \land x_{Customer} \leq Susan \land
    x_{P} \in [20,50] \land
    x_{F} = 5)\\
    \lor &(x_{C} = US \land x_{ID} \in \{13,14\}
          % x_{Customer} \geq Jack \land x_{Customer} \leq Mark \land
           \land
          x_{P} \in [30,60] \land
          x_{F} \in [3,4])
  \end{align*}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For instance, the first two tuples (group \texttt{UK}) get compressed into one conjunction of range constraints. Since the smallest (greatest) price in this group is $20$ ($50$), the range constraint for $x_{P}$ is $x_{P}  \in [20,50]$.
\end{exam}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[t]
  \centering
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \begin{subfigure}{1\linewidth}
    \begin{minipage}{0.3 \textwidth}
      \begin{tabular}{|c|c|c|l}
        \thead{Country} & \thead{Price} & \thead{ShippingFee} &  \\ \cline{1-3}
        $x_{C}$ & $x_{P}$ & $x_{F,2'}$ & $\T$ \\ \cline{1-3}
      \end{tabular}
    \end{minipage}
    \begin{minipage}{0.69 \textwidth}
      \begin{align*}
        \gcond' &= \gcond_{1'} \land \gcond_{2'} \land \adbconstr
                 \hspace{2cm}\gcond_{1'} = (x_{F,1'} = \sqlCase{x_{P} \geq 60}{0}{x_{F}})\\
               & \gcond_{2'} = (x_{F,2'} = \sqlCase{x_{C} = UK \wedge x_{P} \leq 100}{x_{F,1'} + 5}{x_{F,1'}})
      \end{align*}
    \end{minipage}\\[-2mm]
    \caption{VC-database $\ahmod(\vcdbini)$}\label{fig:vc-database-ahmod-vcdbin}
  \end{subfigure}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \begin{subfigure}{0.35\linewidth}
    \begin{tabular}{|c|c|c|l}
      \thead{Country} & \thead{Price} & \thead{ShippingFee} &  \\ \cline{1-3}
      $x_{C}$ & $x_{P}$ & $x_{F,1''}$ & $\T$ \\ \cline{1-3}
    \end{tabular}
    \begin{align*}
      \gcond'' &= \adbconstr \land x_{F,1''} = \sqlCase{x_{P} \geq 50}{0}{x_{F}}
    \end{align*}\\[-10mm]
    \caption{VC-database $\hislice{\{1\}}(\vcdbini)$}\label{fig:vc-database-hislice-histo}
\end{subfigure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hspace{2cm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{subfigure}{0.35\linewidth}
    \begin{tabular}{|c|c|c|l}
      \thead{Country} & \thead{Price} & \thead{ShippingFee} &  \\ \cline{1-3}
      $x_{C}$ & $x_{P}$ & $x_{F,2'}$ & $\T$ \\ \cline{1-3}
    \end{tabular}
    \begin{align*}
      \gcond''' &= \adbconstr \land
                x_{F,1'''} = \sqlCase{x_{P} \geq 60}{0}{x_{F}}
    \end{align*}\\[-10mm]
    %%%%%%%%%%
    \caption{VC-database $\hisliceOf{\ahmod}{\{1\}}$}\label{fig:vc-database-hisliceof-ahm}
  \end{subfigure}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-4mm}
  \caption{VC-database instances for our slicing example. Attributes names are abbreviated as: (C)ounty, (P)rice, Shipping(F)ee.}\label{fig:vc-database-instances-for}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Computing Slices}
\label{sec:test-depend-slic}

To determine whether a given set of indices $\idxs$ is a slice for $\hwhatif$, we have to test whether:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align}
  \label{eq:slice-original-cond}
\iDiff{\history(\db)}{\history[\deltaHist](\db)} = \iDiff{\hslice{\history}{\idxs}(\db)}{\hslice{\history[\deltaHist]}{\idxs}(\db)}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Recall that we restrict program slicing to tuple independent statements (\Cref{def:tuple-independence}). That is, the result produced by such a statement for an input tuple only depends on the values of this tuple and is independent of what other tuples exist in the input. Thus, if both deltas return the same result for every input tuple, then the two deltas are guaranteed to be equal.
% \BG{Argue why this is not a big loss.}
Thus,  $\idxs$ is a slice if for all input tuples from $\db$, both deltas return the same result (see \Cref{eq:tuple-level-slice-test} below). Note that this is only a sufficient, but not necessary condition. To see why this is the case, consider two input tuples $t_1$ and $t_2$ and assume that the delta of the results of the full histories returns $s_1$ for $t_1$ and $s_2$ for $t_2$, but the delta of the results of the sliced histories returns $s_2$ for $t_1$ and $s_1$ for $t_2$. The final result is the same, even though the results for the individual input tuples is different.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align}
  \label{eq:tuple-level-slice-test}
  \begin{split}
    \forall t \in \db:\,\, &\iDiff{\history(\{t\})}{\history[\deltaHist](\{t\})}\\ = &\iDiff{\hslice{\history}{\idxs}(\{t\})}{\hslice{\history[\deltaHist]}{\idxs}(\{t\})}
  \end{split}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




For each $t \in \db$, by construction of $\vcdbini$ (the VC-database we use as input for program slicing), there exists a world  $\db_{t} \in \worldsOf{\vcdbini}$ such that $\db_{t} = \{t\}$. Note that since $\vcdbini$ is generated by compressing the input database into a set of range constraints, some worlds may not correspond to a tuple from $\db$. However, our argument only requires that for each $t \in \db$ there exists a world in $\vcdbini$ which implies that if the condition from \Cref{eq:single-inst-slice-test} evaluates to true for every such $\db_{t}$, then \Cref{eq:tuple-level-slice-test} holds. Thus, the formula shown below is a sufficient condition for $\idxs$ to be a slice.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align}
  \label{eq:single-inst-slice-test}
  \begin{split}
    \forall \db_{t} \in \worldsOf{\vcdbini}:\,\, &\,\,\,\iDiff{\history(\db_{t})}{\history[\deltaHist](\db_{t})}\\ = &\,\,\,\iDiff{\hslice{\history}{\idxs}(\db_{t})}{\hslice{\history[\deltaHist]}{\idxs}(\db_{t})}
  \end{split}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For an input tuple $t$, based on the definition of symmetric difference, $\iDiff{\history(\db_{t})}{\history[\deltaHist](\db_{t})}$ is equal to $\iDiff{\hslice{\history}{\idxs}(\db_{t})}{\hslice{\history[\deltaHist]}{\idxs}(\db_{t})}$ if either (i) $\history(\db_{t}) = \history[\deltaHist](\db_{t})$ and $\hslice{\history}{\idxs}(\db_{t}) = \hslice{\history[\deltaHist]}{\idxs}(\db_{t})$ which means that both deltas return the empty set for $\db_{t}$ or (ii) both deltas return the same set of tuples over $\db_{t}$ which is the case when $\history(\db_{t}) \neq \history[\deltaHist](\db_{t})$ and one of the conditions shown below holds.
\begin{itemize}
\item (a) $\history(\db_{t}) = \hslice{\history}{\idxs}(\db_{t}) \land \history[\deltaHist](\db_{t}) =  \hslice{\history[\deltaHist]}{\idxs}(\db_{t})$
\item (b)
$\history(\db_{t}) = \hslice{\history[\deltaHist]}{\idxs}(\db_{t}) \land \history[\deltaHist](\db_{t}) = \hslice{\history}{\idxs}(\db_{t})$
\end{itemize}
%
 Thus, \Cref{eq:single-inst-slice-test} is equivalent to:
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align}
  \label{eq:slice-test-cases}
  \begin{split}
    &\forall \db_{t} \in \worldsOf{\vcdbini}:\\
    &\left(\history(\db_{t}) = \history[\deltaHist](\db_{t}) \land \hslice{\history}{\idxs}(\db_{t}) = \hslice{\history[\deltaHist]}{\idxs}(\db_{t})\right)   \\
    \lor &(\history(\db_{t}) \neq \history[\deltaHist](\db_{t}) \land\\
    &\hspace{1cm}(
           \history(\db_{t}) = \hslice{\history}{\idxs}(\db_{t}) \land \history[\deltaHist](\db_{t}) =  \hslice{\history[\deltaHist]}{\idxs}(\db_{t})  \\
  &\hspace{0.7cm}\lor \history(\db_{t}) = \hslice{\history[\deltaHist]}{\idxs}(\db_{t}) \land \history[\deltaHist](\db_{t}) = \hslice{\history}{\idxs}(\db_{t})))
  \end{split}
\end{align}

Based on the semantics of updates over VC-tables, the result of a history over a single tuple instance $\vcdbini$ is an instance with a single tuple whose local condition governs the existence of the tuple in any particular world $\db_{t}$. For a history $\history$ let us denote this tuple as $\singtupH{\history}$. Consider the valuation $\varAssign_{t}$ generating $\db_{t}$. Then for two histories $\history$ and $\history'$, the condition $\history(\db_{t}) = \history'(\db_{t})$ is equivalent to the equation shown below as long as we appropriately rename variables such that the two VC-databases do not share any variables except for the variables from $\vcdbini$. % The top part of this encodes the case where both histories return a tuple (the local conditions of both tuples are true under assignment $\varAssign_t$ and returned tuples are equal. The bottom part of the equation is the case where both histories do not return any result (both local conditions are false).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align}
  \label{eq:db-equals-symbolic}
  \begin{split}
      &(\varAssign_{t}(\singtupH{\history}) = \varAssign_{t}(\singtupH{\history'}) \land  \lcond(\varAssign_{t}(\singtupH{\history})) \land \lcond(\varAssign_{t}(\singtupH{\history'})))\\
  \vee &(\neg \lcond(\varAssign_{t}(\singtupH{\history})) \land \neg \lcond(\varAssign_{t}(\singtupH{\history'})))
  \end{split}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
Intuitively, this condition means that for the two histories to return the same result over $\db_{t}$, either (i) they both return the same result tuple (equal values and the local condition of the result tuple evaluates to true for both histories) or (ii) they both return the empty set (the local condition evaluates to false for both histories).

If we substitute this equation into \Cref{eq:slice-test-cases}, then we get a universally quantified first order sentence (a formula without free variables) over the variables from the VC-database $\vcdbini$. We will use $\aslicetest$ to denote the resulting formula (recall that $\adbconstr$ denotes the constraints encoding the compressed database). We can now use a constraint solver to determine whether $\aslicetest$ is true by checking that its negation is unsatisfiable. We use an MILP-solver for this purpose. The translation rules for transforming a logical condition into an MILP program are mostly well-known rules applied in linear programming and many have been used in related work (e.g.,~\cite{MeliouS12}). We refer the interested reader to \cite{techreport} for the details.
  % and discuss in \Cref{sec:sym-lin} how to translate formulas for slice testing into MILP-programs.
  We are now ready to state the main result of this section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{theo}[Slicing Condition]\label{theo:slicing-condition-co}
Let $\hwhatif = (\history, \db, \deltaHist)$ be a historical what-if query where $\history$ is a history with $n$ statements (updates and deletes). If $\aslicetest$ is true, then $\idxs$ is a slice for $\hwhatif$.
\end{theo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifnottechreport{
  \begin{proofsketch}
We first prove that \Cref{eq:tuple-level-slice-test}  implies \Cref{eq:slice-original-cond} for histories consisting of updates and deletes which are both tuple independent. This follows from the definition of tuple independence (\Cref{def:tuple-independence}). \Cref{eq:tuple-level-slice-test} is implied by \Cref{eq:single-inst-slice-test}, because the  worlds of $\vcdbini$ encode a superset of $\db$ by construction and \Cref{theo:vc-updates-are-possible-worlds-semantics} (updates have possible world semantics). The equivalence of \Cref{eq:slice-test-cases} and \Cref{eq:single-inst-slice-test} follows from the definition of database deltas. Finally, the equivalence of $\history(\db_{t}) = \history'(\db_{t})$ and \Cref{eq:db-equals-symbolic} follows from \Cref{theo:vc-updates-are-possible-worlds-semantics}.
  \end{proofsketch}
}
\iftechreport{
\input{ps-proof.tex}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exam}[Testing Slice Candidates]\label{ex:testing-slice-candidates}
Consider our running example database (\Cref{fig:running-example-instance}) and the history $\history = \{u_1,u_2\}$ from \Cref{ex:up-vctb} and let ${u_1}' = \update{ShippingFee \gets 0}{Price \geq 60}$. Let $\vcdbini$ be as shown in \Cref{fig:running-vctb}, but with $\gcond = \gcond_1\land \gcond_2 \land \adbconstr$ where $\adbconstr$ is the database constraint from \Cref{ex:compressing-databases}. Furthermore, consider a \abbrHW $\hwhatif = (\history, \deltaHist)$ for $\deltaHist = ( u_1 \gets u_1' )$ (higher price requirements for waiving shipping fees). To test whether $\idxs = \{1\}$ is a slice, we first have to construct $\slicetest{\hwhatif}{\idxs}{\adbconstr}$ for which we have to evaluate $\history$, $\ahmod$, $\hislice{\{1\}}$, and $\hisliceOf{\ahmod}{\{1\}}$ over $\vcdbini$. The results are shown in \Cref{fig:vc-database-instances-for}. We use $\gcond$ to denote the global condition of $\history(\vcdbini)$, $\gcond'$ for $\ahmod(\vcdbini)$, $\gcond''$ for $\hislice{\{1\}}(\vcdbini)$, and $\gcond'''$ for $\hisliceOf{\ahmod}{\{1\}}(\vcdbini)$.
  Since the local condition of the result tuple is true in the result of both histories and their slices, we do not have to test whether the local condition is true or false as done in \Cref{eq:db-equals-symbolic} and can instead directly test equality of two history's result tuples to test whether the histories return the same result. Furthermore, observe that all four histories only modify attribute \texttt{ShippingFee}. Thus, it is sufficient to compare tuples on attribute \texttt{ShippingFee} to determine whether the result tuples are the same. Applying these simplifications, $\slicetest{\hwhatif}{\idxs}{\adbconstr}$ is equal to:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \begin{align*}
    \forall x_{I}, x_{P}, x_{F}:\,\,\, &\adbconstr \land \gcond \land \gcond' \land \gcond'' \land \gcond''' \land\\
                                 &\hspace{2mm}(
                                   (x_{F,2} = x_{F,2'} \land x_{F,1''} = x_{F,1'''})\\
                                 &\lor (x_{F,2} \neq x_{F,2'} \land ((x_{F,2} = x_{F,1''} \land x_{F,2'} = x_{F,1'''})\\
                                 &\hspace{2.1cm}\vee (x_{F,2} = x_{F,1'''} \land x_{F,2'} = x_{F,1''})))
      )
  \end{align*}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This formula is not true for all possible input tuples. For instance, if the shipping fee is $x_{F} = 55$ and country is $x_{C} = UK$, then the final shipping fee for $\history$ ($x_{F,2}$) is \$5 and for $\ahmod$ is \$50. Thus, $\history(\varAssign(\vcdbini)) \neq \ahmod(\varAssign(\vcdbini))$. Since the slice candidate $\idxs = \{1\}$ does not apply the second update, we get \$0 (for $\hislice{\idxs}$) and \$45 (for $\hisliceOf{\ahmod}{\idxs}$). Thus, the slice candidate may produce a  result for this database that is different to the one returned by $\hwhatif$ which means that $\idxs$ is not a valid slice.
\end{exam}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Our Slicing Algorithm}
\label{sec:finding-slice}
%
Given a set of indexes $\idxs$, we now have a sound method for testing whether $\idxs$ is a slice for a historical what-if query $\hwhatif$. A brute force approach for computing a slice would be to test all possible subsets of indexes to determine the smallest possible slice. Note that even this method is not guaranteed to return a minimal slice, because the test we have devised is not complete. The disadvantage of the brute force approach is that there is an exponential number of candidates (all subsets of the histories). We propose instead a greedy algorithm that considers a linear number of candidates. The algorithm starts with a trivial slice $\idxs_{0} = [1,n]$ where $n$ is the number of updates in the history (recall from \Cref{sec:filter} that we can pad histories such that both $\history$ and $\ahmod$ have $n$ statements). It then iterates for $n$ steps. In each iteration, we remove index $i$ from the current slice $\idxs_{i}$ and test whether $\idxs_{i} - \{i\}$ is still a slice. If yes, then we set $\idxs_{i+1} = \idxs_{i} - \{i\}$. Otherwise, $\idxs_{i+1} = \idxs_{i}$. The final result produced by this algorithm is $\idxs_{n}$ which is guaranteed to be a valid slice.
\BG{Add pseudocode for the algorithm}
\BG{Adapt example}


In~\cite{techreport}, we present an additional optimized version of the slicing condition $\aslicetest$  that only works for single modifications.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "historical_whatif"
%%% End:
